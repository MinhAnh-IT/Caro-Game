<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Room WebSocket Test</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        input, textarea, button {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            margin: 5px 0;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .log-area {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f8f9fa;
            font-family: monospace;
            font-size: 12px;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #007bff;
            background-color: #e3f2fd;
        }
        .error {
            border-left-color: #dc3545;
            background-color: #f8d7da;
            color: #721c24;
        }
        .success {
            border-left-color: #28a745;
            background-color: #d4edda;
            color: #155724;
        }
        .flex-container {
            display: flex;
            gap: 20px;
        }
        .flex-item {
            flex: 1;
        }
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .wide-button {
            grid-column: 1 / -1;
        }
        .hidden {
            display: none !important;
        }
        .game-state {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #007bff;
        }
        .notification {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            animation: fadeIn 0.5s;
        }
        .notification.opponent {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            color: #856404;
        }
        .notification.system {
            background-color: #d1ecf1;
            border-left: 4px solid #17a2b8;
            color: #0c5460;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .player-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .player-info {
            font-weight: bold;
        }
        .ready-indicator {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .ready-indicator.ready {
            background: #d4edda;
            color: #155724;
        }
        .ready-indicator.not-ready {
            background: #f8d7da;
            color: #721c24;
        }
        .ready-indicator.in-game {
            background: #cce7ff;
            color: #004085;
        }
    </style>
</head>
<body>
    <h1>üéÆ Game Room WebSocket Test Interface</h1>
    
    <!-- Connection Configuration -->
    <div class="container">
        <h2>üîå WebSocket Connection</h2>
        <div class="flex-container">
            <div class="flex-item">
                <div class="form-group">
                    <label for="serverUrl">Server URL:</label>
                    <input type="text" id="serverUrl" value="http://localhost:8080/ws" 
                           placeholder="WebSocket endpoint URL">
                </div>
                <div class="form-group">
                    <label for="jwtToken">JWT Token (Enter once):</label>
                    <input type="text" id="jwtToken" 
                           placeholder="Enter your JWT token here">
                </div>
            </div>
            <div class="flex-item">
                <div class="form-group">
                    <label for="roomId">Room ID:</label>
                    <input type="number" id="roomId" value="1" placeholder="Enter room ID">
                </div>
                <div class="action-buttons">
                    <button onclick="connect()" id="connectBtn">Connect</button>
                    <button onclick="disconnect()" id="disconnectBtn" disabled>Disconnect</button>
                </div>
            </div>
        </div>
        <div id="connectionStatus" class="status disconnected">Disconnected</div>
    </div>

    <!-- Game State Info -->
    <div class="container" id="gameStateContainer" style="display: none;">
        <h2>üéÆ Game State</h2>
        <div class="game-state">
            <div><strong>Room ID:</strong> <span id="currentRoomDisplay">-</span></div>
            <div><strong>Game Status:</strong> <span id="gameStatus">-</span></div>
            <div><strong>Players:</strong> <span id="playerCount">0/2</span></div>
        </div>
        <div class="player-status">
            <div class="player-info">You: <span id="yourStatus">Not Ready</span></div>
            <div class="player-info">Opponent: <span id="opponentStatus">Not Ready</span></div>
        </div>
    </div>

    <!-- Room Actions -->
    <div class="container" id="roomActionsContainer" style="display: none;">
        <h2>üè† Room Actions</h2>
        <div class="action-buttons">
            <button onclick="joinRoom()" id="joinBtn" class="hidden">Join Room</button>
            <button onclick="leaveRoom()" id="leaveBtn" class="hidden">Leave Room</button>
            <button onclick="markPlayerReady()" id="readyBtn" class="hidden" style="background-color: #28a745;">Mark Ready</button>
            <button onclick="startGame()" id="startBtn" class="hidden">Start Game (Legacy)</button>
            <button onclick="getRoomStatus()" id="statusBtn">Get Room Status</button>
            <button onclick="surrenderGame()" id="surrenderBtn" class="hidden">Surrender Game</button>
        </div>
        <div class="action-buttons" style="margin-top: 10px;">
            <button onclick="requestRematch()" id="requestRematchBtn" class="hidden" style="background-color: #007bff;">Request Rematch</button>
            <button onclick="acceptRematch()" id="acceptRematchBtn" class="hidden" style="background-color: #28a745;">Accept Rematch</button>
            <button onclick="createRematch()" id="rematchBtn" class="hidden" style="background-color: #6c757d;">Create Rematch (Legacy)</button>
        </div>
        <div class="action-buttons" style="margin-top: 10px;">
            <button onclick="checkRematchConditions()" class="wide-button" style="background-color: #17a2b8;">üîç Check Rematch Conditions</button>
        </div>
    </div>

    <!-- Chat Interface -->
    <div class="container" id="chatContainer" style="display: none;">
        <h2>üí¨ Chat Interface</h2>
        <div class="form-group">
            <label for="chatMessage">Message:</label>
            <textarea id="chatMessage" rows="3" placeholder="Type your message here..." disabled></textarea>
        </div>
        <button onclick="sendChatMessage()" id="chatBtn" disabled class="wide-button">Send Chat Message</button>
    </div>

    <!-- Notifications -->
    <div class="container" id="notificationsContainer" style="display: none;">
        <h2>üîî Live Notifications</h2>
        <div id="notificationArea" class="log-area" style="height: 150px;"></div>
        <button onclick="clearNotifications()" class="wide-button">Clear Notifications</button>
    </div>

    <!-- Message Logs -->
    <div class="flex-container">
        <div class="container flex-item">
            <h2>üì• Received Messages</h2>
            <div id="messageLog" class="log-area"></div>
            <button onclick="clearLog()">Clear Log</button>
        </div>
        <div class="container flex-item">
            <h2>üì§ Sent Messages</h2>
            <div id="sentLog" class="log-area"></div>
            <button onclick="clearSentLog()">Clear Sent Log</button>
        </div>
    </div>

    <!-- Instructions -->
    <div class="container">
        <h2>üìã Instructions</h2>
        <ol>
            <li><strong>Get JWT Token:</strong> First login through your app and copy the JWT token</li>
            <li><strong>Connect:</strong> Paste the token and click "Connect"</li>
            <li><strong>Join Room:</strong> Click "Join Room" to enter the game room</li>
            <li><strong>Mark Ready:</strong> Click "Mark Ready" when you're ready to start (NEW 2-step flow)</li>
            <li><strong>Test Legacy:</strong> Use "Start Game (Legacy)" for old flow</li>
            <li><strong>Chat:</strong> Send chat messages and see real-time responses</li>
            <li><strong>End Game:</strong> Use "Surrender Game" or "Leave Room" to end game</li>
            <li><strong>Rematch (NEW):</strong> Use "Request Rematch" ‚Üí "Accept Rematch" flow or legacy "Create Rematch"</li>
            <li><strong>Monitor:</strong> Watch the logs for incoming and outgoing messages</li>
        </ol>
        
        <h3>üéØ Enhanced Game Flow (NEW):</h3>
        <ol>
            <li>Players join room ‚Üí Status: WAITING</li>
            <li>Both players click "Mark Ready" ‚Üí Auto-start game</li>
            <li>Game plays ‚Üí Status: PLAYING</li>
            <li>Game ends ‚Üí Status: FINISHED</li>
            <li>Player 1: "Request Rematch" ‚Üí Player 2: "Accept Rematch" ‚Üí New room created</li>
        </ol>
        
        <h3>üéØ WebSocket Endpoints (Backend Controlled):</h3>
        <ul>
            <li><code>/app/room/{roomId}/join</code> - Join room</li>
            <li><code>/app/room/{roomId}/leave</code> - Leave room (loses if game active)</li>
            <li><code>/app/room/{roomId}/ready</code> - Mark ready to start (NEW 2-step)</li>
            <li><code>/app/room/{roomId}/start</code> - Start game (legacy)</li>
            <li><code>/app/room/{roomId}/chat</code> - Send chat message</li>
            <li><code>/app/room/{roomId}/status</code> - Get room status</li>
            <li><code>/app/room/{roomId}/surrender</code> - Surrender game</li>
            <li><code>/app/room/{roomId}/rematch/request</code> - Request rematch (NEW 2-step)</li>
            <li><code>/app/room/{roomId}/rematch/accept</code> - Accept rematch (NEW 2-step)</li>
            <li><code>/app/room/{roomId}/rematch</code> - Create rematch (legacy)</li>
        </ul>
        
        <h3>üì° Subscribed Topics:</h3>
        <ul>
            <li><code>/topic/room/{roomId}/chat</code> - Chat messages</li>
            <li><code>/topic/room/{roomId}/updates</code> - Room updates</li>
            <li><code>/queue/user/errors</code> - Error messages</li>
        </ul>
        
        <h3>üîÑ Room Update Events (NEW):</h3>
        <ul>
            <li><code>PLAYER_JOINED</code> - Player joined room</li>
            <li><code>PLAYER_LEFT</code> - Player left room</li>
            <li><code>PLAYER_READY</code> - Player marked as ready (NEW)</li>
            <li><code>GAME_STARTED</code> - Game auto-started when both ready</li>
            <li><code>GAME_ENDED_BY_SURRENDER</code> - Player surrendered</li>
            <li><code>GAME_ENDED_BY_LEAVE</code> - Player left during game</li>
            <li><code>REMATCH_REQUESTED</code> - Rematch request sent (NEW)</li>
            <li><code>REMATCH_ACCEPTED</code> - Rematch request accepted (NEW)</li>
            <li><code>REMATCH_CREATED</code> - New rematch room created</li>
        </ul>
    </div>

    <script>
        let stompClient = null;
        let isConnected = false;
        let currentRoomId = null;
        let gameState = {
            status: 'DISCONNECTED',
            playerCount: 0,
            yourReady: false,
            opponentReady: false,
            inRoom: false,
            gameActive: false,
            canRematch: false
        };
        let storedToken = '';

        // Game State Management
        function updateGameState(newState) {
            gameState = { ...gameState, ...newState };
            updateUI();
            updateButtonVisibility();
        }

        function updateUI() {
            // Update connection status
            const statusElement = document.getElementById('connectionStatus');
            if (isConnected) {
                statusElement.textContent = `Connected ‚úÖ ${storedToken ? '(Token stored)' : ''}`;
                statusElement.className = 'status connected';
            } else {
                statusElement.textContent = 'Disconnected ‚ùå';
                statusElement.className = 'status disconnected';
            }

            // Update game state display
            if (gameState.inRoom) {
                document.getElementById('gameStateContainer').style.display = 'block';
                document.getElementById('currentRoomDisplay').textContent = currentRoomId;
                document.getElementById('gameStatus').textContent = gameState.status;
                document.getElementById('playerCount').textContent = `${gameState.playerCount}/2`;
                
                // Update player status
                document.getElementById('yourStatus').textContent = gameState.yourReady ? 
                    (gameState.gameActive ? 'In Game' : 'Ready') : 'Not Ready';
                document.getElementById('opponentStatus').textContent = gameState.opponentReady ? 
                    (gameState.gameActive ? 'In Game' : 'Ready') : 'Not Ready';
            } else {
                document.getElementById('gameStateContainer').style.display = 'none';
            }

            // Show/hide containers based on connection
            document.getElementById('roomActionsContainer').style.display = isConnected ? 'block' : 'none';
            document.getElementById('chatContainer').style.display = isConnected && gameState.inRoom ? 'block' : 'none';
            document.getElementById('notificationsContainer').style.display = isConnected ? 'block' : 'none';
        }

        function updateButtonVisibility() {
            // Hide all buttons first
            const allButtons = ['joinBtn', 'leaveBtn', 'readyBtn', 'startBtn', 'surrenderBtn', 
                              'requestRematchBtn', 'acceptRematchBtn', 'rematchBtn'];
            allButtons.forEach(btnId => {
                document.getElementById(btnId).classList.add('hidden');
            });

            if (!isConnected) return;

            // Debug current state
            console.log('üîç Button Visibility Debug:', {
                inRoom: gameState.inRoom,
                status: gameState.status,
                yourReady: gameState.yourReady,
                playerCount: gameState.playerCount,
                gameActive: gameState.gameActive,
                canRematch: gameState.canRematch
            });

            // Show buttons based on game state
            if (!gameState.inRoom) {
                // Not in room - show join button
                document.getElementById('joinBtn').classList.remove('hidden');
            } else if (gameState.status === 'WAITING' || gameState.status === 'WAITING_FOR_READY' || gameState.status === 'JOINING') {
                // In room, waiting phase (including joining state)
                document.getElementById('leaveBtn').classList.remove('hidden');
                
                // Show ready button if player is in room and not ready yet
                // Allow ready even if we don't know exact player count yet
                if (!gameState.yourReady) {
                    document.getElementById('readyBtn').classList.remove('hidden');
                    console.log('‚úÖ Ready button shown - player not ready yet');
                }
                
                // Legacy start button for host (only when we know there are 2 players)
                if (gameState.playerCount >= 2) {
                    document.getElementById('startBtn').classList.remove('hidden');
                }
            } else if (gameState.status === 'PLAYING') {
                // Game active
                document.getElementById('leaveBtn').classList.remove('hidden');
                document.getElementById('surrenderBtn').classList.remove('hidden');
            } else if (gameState.status === 'FINISHED') {
                // Game finished
                document.getElementById('leaveBtn').classList.remove('hidden');
                
                if (gameState.canRematch) {
                    document.getElementById('requestRematchBtn').classList.remove('hidden');
                    document.getElementById('rematchBtn').classList.remove('hidden');
                }
            }

            // Enable/disable chat
            document.getElementById('chatMessage').disabled = !gameState.inRoom;
            document.getElementById('chatBtn').disabled = !gameState.inRoom;
        }

        function addNotification(message, type = 'system', isOpponent = false) {
            const notificationArea = document.getElementById('notificationArea');
            const notification = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            
            notification.className = `notification ${isOpponent ? 'opponent' : type}`;
            
            const icon = isOpponent ? 'üë§' : (type === 'system' ? 'üîî' : 'üì°');
            const prefix = isOpponent ? 'Opponent' : 'System';
            
            notification.innerHTML = `<strong>[${timestamp}] ${icon} ${prefix}:</strong> ${message}`;
            
            notificationArea.appendChild(notification);
            notificationArea.scrollTop = notificationArea.scrollHeight;
            
            // Also add to regular message log
            addMessage(`${icon} ${prefix}: ${message}`, type === 'system' ? 'success' : 'info');
        }

        function clearNotifications() {
            document.getElementById('notificationArea').innerHTML = '';
        }

        function connect() {
            const serverUrl = document.getElementById('serverUrl').value;
            const jwtToken = document.getElementById('jwtToken').value;
            currentRoomId = document.getElementById('roomId').value;
            
            if (!jwtToken && !storedToken) {
                addMessage('‚ùå Please enter JWT token', 'error');
                return;
            }

            if (!currentRoomId) {
                addMessage('‚ùå Please enter room ID', 'error');
                return;
            }

            // Store token if provided, or use stored token
            if (jwtToken.trim()) {
                storedToken = jwtToken.trim();
                if (storedToken.startsWith('Bearer ')) {
                    storedToken = storedToken.substring(7);
                }
                // Clear the input field after storing
                document.getElementById('jwtToken').value = '';
                document.getElementById('jwtToken').placeholder = 'Token stored ‚úì';
            }

            const connectionUrl = `${serverUrl}?token=${encodeURIComponent(storedToken)}`;
            addSentMessage(`üîå Connecting to ${serverUrl} with stored token...`);

            // Disable connect button and inputs during connection
            document.getElementById('connectBtn').disabled = true;
            document.getElementById('serverUrl').disabled = true;
            document.getElementById('jwtToken').disabled = true;
            document.getElementById('roomId').disabled = true;

            try {
                const wsUrl = connectionUrl.replace('http:', 'ws:').replace('https:', 'wss:');
                const socket = new WebSocket(wsUrl);
                stompClient = Stomp.over(socket);
            } catch (e) {
                const socket = new SockJS(connectionUrl);
                stompClient = Stomp.over(socket);
            }

            stompClient.debug = function(str) {
                console.log('STOMP:', str);
            };

            stompClient.connect({}, 
                function(frame) {
                    isConnected = true;
                    updateGameState({ status: 'CONNECTED' });
                    addMessage('‚úÖ Connected to WebSocket successfully!', 'success');
                    addNotification('Connected to game server', 'system');
                    subscribeToTopics();
                    
                    // Enable disconnect button
                    document.getElementById('disconnectBtn').disabled = false;
                    console.log('WebSocket Connected:', frame);
                },
                function(error) {
                    isConnected = false;
                    updateGameState({ status: 'DISCONNECTED' });
                    addMessage(`‚ùå Connection error: ${error}`, 'error');
                    
                    // Re-enable connect button and inputs
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('serverUrl').disabled = false;
                    document.getElementById('jwtToken').disabled = false;
                    document.getElementById('roomId').disabled = false;
                    console.error('WebSocket Error:', error);
                }
            );
        }

        function disconnect() {
            if (stompClient !== null) {
                stompClient.disconnect();
            }
            isConnected = false;
            updateGameState({ 
                status: 'DISCONNECTED', 
                inRoom: false, 
                gameActive: false,
                yourReady: false,
                opponentReady: false,
                playerCount: 0
            });
            addMessage('üîå Disconnected from WebSocket', 'success');
            addNotification('Disconnected from game server', 'system');
            
            // Reset UI elements
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            document.getElementById('serverUrl').disabled = false;
            document.getElementById('jwtToken').disabled = false;
            document.getElementById('roomId').disabled = false;
        }

        function subscribeToTopics() {
            if (!isConnected || !currentRoomId) return;

            // Subscribe to room chat messages
            stompClient.subscribe(`/topic/room/${currentRoomId}/chat`, function(message) {
                try {
                    const chatData = JSON.parse(message.body);
                    addMessage(`üí¨ Chat: ${chatData.username || 'Player'}: ${chatData.message || chatData.content}`, 'success');
                    addNotification(`Chat: ${chatData.message || chatData.content}`, 'system', true);
                } catch (e) {
                    addMessage(`üí¨ Chat (raw): ${message.body}`, 'success');
                }
            });

            // Subscribe to room updates
            stompClient.subscribe(`/topic/room/${currentRoomId}/updates`, function(message) {
                try {
                    const updateData = JSON.parse(message.body);
                    addMessage(`üîÑ Room Update: ${updateData.updateType}`, 'success');
                    
                    handleRoomUpdate(updateData);
                } catch (e) {
                    addMessage(`üîÑ Room Update (raw): ${message.body}`, 'success');
                }
            });

            // Subscribe to room status responses
            stompClient.subscribe(`/topic/room/${currentRoomId}/status`, function(message) {
                try {
                    const statusData = JSON.parse(message.body);
                    addMessage(`üìä Room Status: ${JSON.stringify(statusData)}`, 'success');
                    
                    // Update game state based on status response
                    if (statusData.roomId && statusData.status) {
                        updateGameState({
                            inRoom: true,
                            status: statusData.status,
                            playerCount: statusData.playerCount || statusData.players?.length || gameState.playerCount
                        });
                        addNotification(`Room status updated: ${statusData.status}`, 'system');
                    }
                } catch (e) {
                    addMessage(`üìä Room Status (raw): ${message.body}`, 'success');
                }
            });

            // Subscribe to error messages
            stompClient.subscribe('/queue/user/errors', function(message) {
                try {
                    const errorData = JSON.parse(message.body);
                    addMessage(`‚ö†Ô∏è Error: ${errorData.message || JSON.stringify(errorData)}`, 'error');
                    addNotification(`Error: ${errorData.message}`, 'system');
                } catch (e) {
                    addMessage(`‚ö†Ô∏è Error (raw): ${message.body}`, 'error');
                }
            });

            addMessage(`üì° Subscribed to topics for room ${currentRoomId}`, 'success');
        }

        function resubscribeToNewRoom() {
            if (!isConnected || !currentRoomId) {
                addMessage('‚ùå Cannot resubscribe: not connected or no room ID', 'error');
                return;
            }

            // Re-subscribe to the new room topics
            // Note: STOMP automatically handles multiple subscriptions
            // New subscriptions will override the old ones for the same callback functions
            
            // Subscribe to room chat messages for new room
            stompClient.subscribe(`/topic/room/${currentRoomId}/chat`, function(message) {
                try {
                    const chatData = JSON.parse(message.body);
                    addMessage(`üí¨ Chat: ${chatData.username || 'Player'}: ${chatData.message || chatData.content}`, 'success');
                    addNotification(`Chat: ${chatData.message || chatData.content}`, 'system', true);
                } catch (e) {
                    addMessage(`üí¨ Chat (raw): ${message.body}`, 'success');
                }
            });

            // Subscribe to room updates for new room
            stompClient.subscribe(`/topic/room/${currentRoomId}/updates`, function(message) {
                try {
                    const updateData = JSON.parse(message.body);
                    addMessage(`üîÑ Room Update: ${updateData.updateType}`, 'success');
                    
                    handleRoomUpdate(updateData);
                } catch (e) {
                    addMessage(`üîÑ Room Update (raw): ${message.body}`, 'success');
                }
            });

            // Subscribe to room status responses for new room
            stompClient.subscribe(`/topic/room/${currentRoomId}/status`, function(message) {
                try {
                    const statusData = JSON.parse(message.body);
                    addMessage(`üìä Room Status: ${JSON.stringify(statusData)}`, 'success');
                    
                    // Update game state based on status response
                    if (statusData.roomId && statusData.status) {
                        updateGameState({
                            inRoom: true,
                            status: statusData.status,
                            playerCount: statusData.playerCount || statusData.players?.length || gameState.playerCount
                        });
                        addNotification(`Room status updated: ${statusData.status}`, 'system');
                    }
                } catch (e) {
                    addMessage(`üìä Room Status (raw): ${message.body}`, 'success');
                }
            });

            // Error subscription remains the same (user-specific)
            addMessage(`üì° Re-subscribed to topics for NEW room ${currentRoomId}`, 'success');
            addNotification(`üì° Now listening to room ${currentRoomId} events`, 'system');
        }

        function handleRoomUpdate(updateData) {
            switch (updateData.updateType) {
                case 'PLAYER_JOINED':
                    const newPlayerCount = updateData.playerCount || Math.max(gameState.playerCount || 0, 1);
                    updateGameState({ 
                        inRoom: true, 
                        playerCount: newPlayerCount,
                        status: newPlayerCount >= 2 ? 'WAITING_FOR_READY' : 'WAITING' 
                    });
                    
                    if (updateData.playerName) {
                        addNotification(`${updateData.playerName} joined the room`, 'system', true);
                    } else {
                        addNotification('A player joined the room', 'system', true);
                    }
                    break;

                case 'PLAYER_LEFT':
                    updateGameState({ 
                        playerCount: Math.max(0, (gameState.playerCount || 2) - 1),
                        opponentReady: false
                    });
                    addNotification('A player left the room', 'system', true);
                    break;

                case 'PLAYER_READY':
                    const readyCount = updateData.readyCount || 0;
                    updateGameState({ 
                        status: 'WAITING_FOR_READY',
                        opponentReady: readyCount > (gameState.yourReady ? 0 : 1)
                    });
                    addNotification(`Player marked as ready! (${readyCount}/2 ready)`, 'system', true);
                    break;

                case 'GAME_STARTED':
                    updateGameState({ 
                        status: 'PLAYING', 
                        gameActive: true,
                        yourReady: true,
                        opponentReady: true
                    });
                    addNotification('üéÆ Game has started! Good luck!', 'system');
                    break;

                case 'GAME_ENDED_BY_SURRENDER':
                    updateGameState({ 
                        status: 'FINISHED', 
                        gameActive: false, 
                        canRematch: true 
                    });
                    addNotification('üè≥Ô∏è Opponent surrendered. You win!', 'system', true);
                    break;

                case 'GAME_ENDED_BY_LEAVE':
                    updateGameState({ 
                        status: 'FINISHED', 
                        gameActive: false, 
                        canRematch: false 
                    });
                    addNotification('üö™ Opponent left during game. You win!', 'system', true);
                    break;

                case 'GAME_COMPLETED':
                    updateGameState({ 
                        status: 'FINISHED', 
                        gameActive: false, 
                        canRematch: true 
                    });
                    addNotification('üéØ Game completed!', 'system');
                    break;

                case 'REMATCH_REQUESTED':
                    addNotification(`üîÑ ${updateData.requesterName || 'Opponent'} requested a rematch!`, 'system', true);
                    document.getElementById('acceptRematchBtn').classList.remove('hidden');
                    break;

                case 'REMATCH_ACCEPTED':
                    addNotification(`‚úÖ ${updateData.accepterName || 'Opponent'} accepted the rematch!`, 'system', true);
                    break;

                case 'REMATCH_CREATED':
                    if (updateData.newRoomId) {
                        addNotification(`üÜï New rematch room created: ${updateData.newRoomId}`, 'system');
                        // Auto switch to new room
                        const oldRoomId = currentRoomId;
                        currentRoomId = updateData.newRoomId;
                        document.getElementById('roomId').value = currentRoomId;
                        
                        // Re-subscribe to new room topics
                        addNotification(`üîÑ Switching from room ${oldRoomId} to room ${currentRoomId}`, 'system');
                        resubscribeToNewRoom();
                        
                        updateGameState({
                            status: 'WAITING_FOR_READY',
                            gameActive: false,
                            yourReady: false,
                            opponentReady: false,
                            canRematch: false,
                            inRoom: true,
                            playerCount: 2
                        });
                        addNotification('üîÑ Switched to rematch room. Get ready!', 'system');
                    }
                    break;

                default:
                    addNotification(`Room update: ${updateData.updateType}`, 'system');
            }
        }

        function joinRoom() {
            if (!isConnected) return;
            
            const destination = `/app/room/${currentRoomId}/join`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`üö™ Sent join room request to ${destination}`);
            updateGameState({ 
                inRoom: true, 
                status: 'WAITING', // Set to WAITING instead of JOINING for immediate button visibility
                playerCount: Math.max(gameState.playerCount || 0, 1), // At least 1 (yourself)
                yourReady: false, // Ensure ready state is reset when joining
                opponentReady: false // Reset opponent ready state as well
            });
            
            // Trigger status check after join to get accurate room state
            setTimeout(() => {
                if (isConnected && storedToken) {
                    getRoomStatus();
                }
            }, 500); // Small delay to ensure join is processed
        }

        function leaveRoom() {
            if (!isConnected) return;
            
            if (!confirm('Are you sure you want to leave the room?')) {
                return;
            }
            
            const destination = `/app/room/${currentRoomId}/leave`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`üö™ Sent leave room request to ${destination}`);
            updateGameState({ 
                inRoom: false, 
                status: 'LEAVING',
                yourReady: false,
                opponentReady: false,
                gameActive: false,
                playerCount: 0
            });
        }

        function markPlayerReady() {
            if (!isConnected) return;
            
            const destination = `/app/room/${currentRoomId}/ready`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`‚úÖ Sent mark ready request to ${destination}`);
            
            updateGameState({ yourReady: true });
            addNotification('You marked as ready! Waiting for opponent...', 'system');
        }

        function surrenderGame() {
            if (!isConnected) return;
            
            if (!confirm('Are you sure you want to surrender? You will lose the game.')) {
                return;
            }
            
            const destination = `/app/room/${currentRoomId}/surrender`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`üè≥Ô∏è Sent surrender request to ${destination}`);
            
            addNotification('You surrendered the game', 'system');
        }

        function requestRematch() {
            if (!isConnected) return;
            
            if (!confirm('Request a rematch with the same players?')) {
                return;
            }
            
            const destination = `/app/room/${currentRoomId}/rematch/request`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`üîÑ Sent rematch request to ${destination}`);
            
            addNotification('Rematch request sent! Waiting for opponent...', 'system');
            // Hide request button after sending
            document.getElementById('requestRematchBtn').classList.add('hidden');
        }

        function acceptRematch() {
            if (!isConnected) return;
            
            if (!confirm('Accept the rematch request?')) {
                return;
            }
            
            const destination = `/app/room/${currentRoomId}/rematch/accept`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`‚úÖ Sent accept rematch to ${destination}`);
            
            addNotification('Rematch accepted! Creating new room...', 'system');
            // Hide accept button after accepting
            document.getElementById('acceptRematchBtn').classList.add('hidden');
        }

        function startGame() {
            if (!isConnected) return;
            
            const destination = `/app/room/${currentRoomId}/start`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`üéÆ Sent start game request to ${destination}`);
        }

        function getRoomStatus() {
            if (!isConnected) return;
            
            const destination = `/app/room/${currentRoomId}/status`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`üìä Sent room status request to ${destination}`);
            
            // Also check via REST API to get accurate state
            if (storedToken) {
                checkRematchConditions();
            }
        }

        function createRematch() {
            if (!isConnected) return;
            
            if (!confirm('Create a new game with the same players?')) {
                return;
            }
            
            const destination = `/app/room/${currentRoomId}/rematch`;
            stompClient.send(destination, {}, JSON.stringify({}));
            addSentMessage(`üîÑ Sent rematch request to ${destination}`);
            
            addNotification('Creating rematch room...', 'system');
        }

        function sendChatMessage() {
            if (!isConnected) return;
            
            const message = document.getElementById('chatMessage').value;
            if (!message.trim()) {
                addMessage('‚ùå Please enter a message', 'error');
                return;
            }

            const chatData = {
                content: message.trim()
            };

            const destination = `/app/room/${currentRoomId}/chat`;
            stompClient.send(destination, {}, JSON.stringify(chatData));
            addSentMessage(`üí¨ Sent chat message: "${message}"`);
            
            // Clear the message input
            document.getElementById('chatMessage').value = '';
        }

        function checkRematchConditions() {
            if (!isConnected) {
                addMessage('‚ùå Not connected to WebSocket', 'error');
                return;
            }
            
            if (!storedToken) {
                addMessage('‚ùå JWT token required', 'error');
                return;
            }
            
            // Call REST API to check room status
            fetch(`http://localhost:8080/api/rooms/${currentRoomId}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${storedToken}`,
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const room = data.data;
                    addMessage(`üìä Room Status Check:`, 'info');
                    addMessage(`   Status: ${room.status}`, 'info');
                    addMessage(`   Players: ${room.players.length}`, 'info');
                    addMessage(`   Can Rematch: ${room.status === 'FINISHED' && room.players.length === 2}`, 'info');
                    
                    updateGameState({
                        status: room.status,
                        playerCount: room.players.length,
                        canRematch: room.status === 'FINISHED' && room.players.length === 2
                    });
                } else {
                    addMessage(`‚ùå Error checking room: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                addMessage(`‚ùå Failed to check room status: ${error.message}`, 'error');
            });
        }

        function addMessage(message, type = 'info') {
            const messageLog = document.getElementById('messageLog');
            const messageElement = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            
            messageElement.className = `message ${type}`;
            messageElement.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
            
            messageLog.appendChild(messageElement);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        function addSentMessage(message) {
            const sentLog = document.getElementById('sentLog');
            const messageElement = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            
            messageElement.className = 'message';
            messageElement.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
            
            sentLog.appendChild(messageElement);
            sentLog.scrollTop = sentLog.scrollHeight;
        }

        function clearLog() {
            document.getElementById('messageLog').innerHTML = '';
        }

        function clearSentLog() {
            document.getElementById('sentLog').innerHTML = '';
        }

        // Handle Enter key in chat message textarea
        document.getElementById('chatMessage').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatMessage();
            }
        });

        // Initial setup
        updateGameState({ status: 'DISCONNECTED' });
        addMessage('üéÆ Enhanced Game Room WebSocket Test Interface loaded', 'success');
        addMessage('üìù Enter your JWT token once and click Connect to start testing', 'info');
        addNotification('Welcome! Connect to start testing game features.', 'system');
    </script>
</body>
</html>
